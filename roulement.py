# -*- coding: utf-8 -*-
"""roulement.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eqdwOjR6otGQjav2yDcTF4aC1GeOsPPh

#  **Étude de cas : Maintenance Préventive des Roulements de Moteur : Défectueux ou Non Défectueux ?**
#  **Une Analyse Exploratoire des Données**

> Bloc en retrait

Notre entreprise est intéressée par la mise en œuvre d'un système de maintenance préventive, axé sur la détection des anomalies et de l'usure dans les roulements d'un moteur spécifique. Ce système vise à surveiller divers paramètres critiques pour la santé et la performance des roulements. Le jeu de données, créé à des fins d'étude, comprend les mesures de plusieurs capteurs, conçus pour capturer les premiers signes de défaillance ou d'usure dans les roulements. Les caractéristiques clés de ce jeu de données, collectées à partir de capteurs appropriés, sont :

- **Vibration** : Mesure les oscillations du roulement, indiquant un désalignement, un déséquilibre ou un relâchement mécanique.
- **Température** : Le degré de chaleur généré par le roulement, pouvant signifier des problèmes de friction, de surcharge ou de lubrification.
- **Bruit Acoustique** : Le son émis par le roulement en fonctionnement, utile pour détecter des problèmes tels que le brinelling, l'écaillage ou la corrosion.
- **Lubrification** : Évaluation de la qualité et de la quantité du lubrifiant, essentielle pour réduire la friction et l'usure.
- **Charge** : La force appliquée sur le roulement, impactant sa durée de vie et ses performances.
- **Vitesse de Rotation** : La vitesse à laquelle le roulement tourne, affectant ses contraintes opérationnelles et ses schémas d'usure.

Chacune de ces caractéristiques est vitale pour une analyse complète de la santé des roulements. Des algorithmes avancés, en particulier du domaine de l'apprentissage automatique et de l'analyse prédictive, sont utilisés pour analyser ces paramètres. Le jeu de données facilite la création de modèles capables de prédire les défaillances potentielles, permettant des actions de maintenance opportunes pour prévenir des arrêts coûteux et des dommages aux équipements. Avec ces données, les équipes de maintenance peuvent passer d'une stratégie réactive à une stratégie proactive, optimisant la durée de vie et l'efficacité des moteurs.

Toutes les valeurs des caractéristiques sont enregistrées avec précision et couvrent une gamme de conditions opérationnelles pour assurer une modélisation prédictive robuste. Il est important de noter que ces valeurs sont fictives et générées artificiellement pour l'étude. L'objectif est d'exploiter ces données pour identifier les premiers indicateurs de défaillance des roulements, améliorant ainsi la fiabilité et la longévité des systèmes de moteurs.

** Information sur les attributs**:

- **Numéro d'Identifiant (ID)**
- **Statut (Status)** : M = défectueux (malignant), B = correct (benign)

<h2 align=center>Diagnostic des Roulements (Partie 1) : Analyse Prédictive de Maintenance</h2>


Dans le contexte de la maintenance préventive des roulements (bearings), voici une description détaillée des caractéristiques que pourrait contenir un jeu de données :

1. **ID** : Identifiant unique pour chaque roulement.
2. **Statut (status)** : Indique l'état du roulement (par exemple, M = défectueux/malignant, B = bon état/benign).
3. **Moyenne de Vibration (vibration_mean)** : Moyenne des mesures de vibration.
4. **Moyenne de Température (temperature_mean)** : Moyenne des mesures de température.
5. **Moyenne de Bruit (noise_mean)** : Moyenne des niveaux de bruit acoustique.
6. **Moyenne de Lubrification (lubrication_mean)** : Évaluation moyenne de la lubrification.
7. **Moyenne de Lissage (smoothness_mean)** : Moyenne des variations de surface ou de texture.
8. **Moyenne de Charge (load_mean)** : Moyenne des forces de charge appliquées sur le roulement.
9. **Moyenne de Vitesse de Rotation (rotationspeed_mean)** : Moyenne des vitesses de rotation.
10. **Écart-type de Vibration (vibration_stddev)** : Variabilité des mesures de vibration.
11. **Écart-type de Température (temperature_stddev)** : Variabilité des mesures de température.
12. **Écart-type de Bruit (noise_stddev)** : Variabilité des niveaux de bruit.
13. **Écart-type de Lubrification (lubrication_stddev)** : Variabilité des évaluations de lubrification.
14. **Écart-type de Charge (load_stddev)** : Variabilité des forces de charge.
15. **Écart-type de Vitesse de Rotation (rotationspeed_stddev)** : Variabilité des vitesses de rotation.
16. **Vibration Maximale (vibration_max)** : Valeur maximale enregistrée pour les vibrations.
17. **Température Maximale (temperature_max)** : Valeur maximale enregistrée pour la température.
18. **Bruit Maximal (noise_max)** : Valeur maximale enregistrée pour le bruit.
19. **Lubrification Minimale (lubrication_min)** : Valeur minimale enregistrée pour la lubrification.
20. **Charge Maximale (load_max)** : Valeur maximale enregistrée pour la charge.
21. **Vitesse de Rotation Maximale (rotationspeed_max)** : Valeur maximale enregistrée pour la vitesse de rotation.
22. **Niveau d'Usure (wear_level)** : Évaluation de l'usure du roulement.
23. **Pire Vibration (vibration_worst)** : Les pires valeurs enregistrées pour les vibrations.
24. **Pire Température (temperature_worst)** : Les pires valeurs enregistrées pour la température.
25. **Pire Bruit (noise_worst)** : Les pires valeurs enregistrées pour le bruit.
26. **Pire Lubrification (lubrication_worst)** : Les pires valeurs enregistrées pour la lubrification.
27. **Pire Charge (load_worst)** : Les pires valeurs enregistrées pour la charge.
28. **Pire Vitesse de Rotation (rotationspeed_worst)** : Les pires valeurs enregistrées pour la vitesse de rotation.
29. **Variabilité de Vibration (vibration_variability)** : Mesure de la fluctuation des vibrations.
30. **Variabilité de Température (temperature_variability)** : Mesure de la fluctuation des températures.
31. **Variabilité de Bruit (noise_variability)** : Mesure de la fluctuation des niveaux de bruit.
32. **Variabilité de Lubrification (lubrication_Variability)** : Mesure de la fluctuation des évaluations de lubrification.

Ces caractéristiques permettent une analyse détaillée de l'état de chaque roulement, facilitant ainsi la détection précoce de problèmes potentiels et la mise en œuvre de mesures de maintenance préventive.

### Tâche 1 : Chargement des Bibliothèques et des Données
"""

import numpy as np # algèbre linéaire
import pandas as pd # traitement de données, entrée/sortie de fichiers CSV (par exemple, pd.read_csv)
import seaborn as sns # bibliothèque de visualisation de données
import matplotlib.pyplot as plt # bibliothèque de graphiques
import time # module pour manipuler le temps

data = pd.read_csv('roulement.csv')

"""<h2 align=center> Analyse Exploratoire des Données </h2>

---

### Tâche 2 : Séparer la Cible des Caractéristiques et nettoyage rapide des données
"""

data.head()

B,M = data.status.value_counts()
print(B,M)

data.shape

!pip install missingno
import missingno as msno
msno.matrix(data)

# noms des caractéristiques sous forme de liste
col = data.columns       # .columns donne les noms des colonnes dans data
print(col)

# y inclut nos étiquettes et x inclut nos caractéristiques
y = data.status                          # M ou B
liste = ['Unnamed: 32', 'id', 'status']
x = data.drop(liste, axis = 1)
x.head()

"""### Tâche 3 : Tracer les Distributions de la cible status"""

ax = sns.countplot(x=y, label="Count")
B, M = y.value_counts()
print('Nombre de Corrects (Bénins) : ', B)
print('Nombre de Défectueux (Malignes) : ', M)

#https://www.geeksforgeeks.org/countplot-using-seaborn-in-python/

x.describe()

"""<h2 align=center> Visualisation des Données </h2>

---

### Tâche 4: Visualisation des Données Standardisées avec Seaborn
"""

# Premières dix caractéristiques
data_dia = y
data = x
data_n_2 = (data - data.mean()) / (data.std()) # normalisation
data = pd.concat([y, data_n_2.iloc[:, 0:10]], axis=1)
data = pd.melt(data, id_vars="status",
                    var_name="caractéristiques",
                    value_name='valeur')
#print(data)
plt.figure(figsize=(10,10))
sns.violinplot(x="caractéristiques", y="valeur", hue="status", data=data, split=True, inner="quartile")
plt.xticks(rotation=45);

"""### Tâche 5 : Graphiques en Violon et Boîtes à Moustaches

> Bloc en retrait


"""

# Deuxièmes dix caractéristiques
data = pd.concat([y,data_n_2.iloc[:,10:20]],axis=1)
data = pd.melt(data,id_vars="status",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(10,10))
sns.violinplot(x="features", y="value", hue="status", data=data,split=True, inner="quart")
plt.xticks(rotation=45);

# Troisièmes dix caractéristiques
data = pd.concat([y,data_n_2.iloc[:,20:31]],axis=1)
data = pd.melt(data,id_vars="status",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(10,10))
sns.violinplot(x="features", y="value", hue="status", data=data,split=True, inner="quart")
plt.xticks(rotation=45);

# En alternative au graphique en violon, on peut utiliser un graphique en boîte
# Les graphiques en boîte sont également utiles pour observer les valeurs aberrantes
# Je ne vais pas visualiser toutes les caractéristiques avec un graphique en boîte
# Pour vous montrer, voici un exemple de graphique en boîte
# Si vous le souhaitez, vous pouvez également visualiser d'autres caractéristiques de cette manière.
plt.figure(figsize=(10,10))
sns.boxplot(x="features", y="value", hue="status", data=data)
#sns.boxenplot(x="features", y="value", hue="status", data=data)
plt.xticks(rotation=45);

"""# Tâche 6 : Utilisation de Graphiques Conjoints pour Comparer les Caractéristiques"""

sns.jointplot(x=x.loc[:,'temperature_max'],
              y=x.loc[:,'temperature_worst'],
              kind="reg",
              color="#ce1414");

sns.jointplot(x=x.loc[:,'vibration_variability'],
              y=x.loc[:,'temperature_variability'],
              kind="reg",
              color="#ce1414");

"""# Tâche 7 : Révéler les Caractéristiques Corrélées avec des Grilles de Paires"""

sns.set(style="white")
df = x.loc[:,['vibration_worst','noise_worst','lubrication_worst']]
g = sns.PairGrid(df, diag_sharey=False)
g.map_lower(sns.kdeplot, cmap="Reds")
g.map_upper(plt.scatter)
g.map_diag(sns.kdeplot, lw=3);

sns.set(style="white")
df = x.loc[:,['vibration_worst','temperature_worst','lubrication_worst']]
g = sns.PairGrid(df, diag_sharey=False)
g.map_lower(sns.kdeplot, cmap="Reds")
g.map_upper(plt.scatter)
g.map_diag(sns.kdeplot, lw=3);

"""# Tâche 8 : Observer la Distribution des Valeurs et leur Variance avec des Graphiques Swarm Plots"""

sns.set(style="whitegrid", palette="muted")
data_dia = y
data = x
data_n_2 = (data - data.mean()) / (data.std())    # standardization / normalisation
data = pd.concat([y,data_n_2.iloc[:,0:10]],axis=1)
data = pd.melt(data,id_vars="status",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(10,10))
sns.swarmplot(x="features", y="value", hue="status", data=data)
plt.xticks(rotation=45);

data = pd.concat([y,data_n_2.iloc[:,10:20]],axis=1)
data = pd.melt(data,id_vars="status",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(10,10))
sns.swarmplot(x="features", y="value", hue="status", data=data)
plt.xticks(rotation=45);

data = pd.concat([y,data_n_2.iloc[:,20:31]],axis=1)
data = pd.melt(data,id_vars="status",
                    var_name="features",
                    value_name='value')
plt.figure(figsize=(10,10))
sns.swarmplot(x="features", y="value", hue="status", data=data)
plt.xticks(rotation=45);

"""# Tâche 9: Observation de toutes les corrélations par paires"""

#Carte de corrélation / Correlation map

f,ax = plt.subplots(figsize=(18, 18))
sns.heatmap(x.corr(), annot=True, linewidths=.5, fmt= '.1f',ax=ax);

